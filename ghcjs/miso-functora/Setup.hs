{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PackageImports #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -Werror #-}
{-# OPTIONS_GHC -Weverything #-}
{-# OPTIONS_GHC -Wno-all-missed-specialisations #-}
{-# OPTIONS_GHC -Wno-missed-specialisations #-}
{-# OPTIONS_GHC -Wno-missing-exported-signatures #-}
{-# OPTIONS_GHC -Wno-missing-import-lists #-}
{-# OPTIONS_GHC -Wno-missing-local-signatures #-}
{-# OPTIONS_GHC -Wno-safe #-}
{-# OPTIONS_GHC -Wno-unsafe #-}
{-# OPTIONS_GHC -fprint-potential-instances #-}

import qualified Data.Text as T
import Distribution.Simple hiding (Module (..))
import Distribution.Simple.LocalBuildInfo (LocalBuildInfo (..))
import Distribution.Simple.Utils (writeUTF8File)
import GHC (runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import qualified System.Directory as Directory
import System.Environment (getProgName)
import qualified System.FilePath as FilePath
import qualified Text.Casing as Casing
import Universum hiding (empty)

#if MIN_VERSION_ghc(9,0,0)
import "ghc" GHC.Driver.Session (getDynFlags)
import "ghc" GHC.Utils.Outputable
  ( Outputable (..),
    text,
    vcat,
    ($+$),
  )
#else
import "ghc" DynFlags (getDynFlags)
import "ghc" Outputable
  ( Outputable (..),
    text,
    vcat,
    ($+$),
  )
#endif

main :: IO ()
main =
  defaultMainWithHooks
    simpleUserHooks
      { buildHook = \p l h f ->
          codeGenHook l
            >> buildHook simpleUserHooks p l h f
      }

data Module = Module
  { moduleHeader :: [String],
    moduleBody :: HsModule'
  }

instance Outputable Module where
  ppr m =
    vcat (text <$> moduleHeader m)
      $+$ ppr (moduleBody m)

codeGenHook :: LocalBuildInfo -> IO ()
codeGenHook _ = do
  prog <- getProgName
  runGhc (Just libdir) $ do
    dflags <-
      getDynFlags
    cssKebab <-
      liftIO $ FilePath.takeBaseName <<$>> Directory.listDirectory "css/"
    let cssPascal =
          fmap Casing.pascal cssKebab
    when (cssKebab /= fmap Casing.kebab cssPascal)
      . error
      $ "Bad kebab <-> pascal isomorphism in "
      <> show cssKebab
    liftIO
      . writeFileIfChanged
      . showPpr dflags
      $ generateCode prog cssPascal

generateCode :: String -> [String] -> Module
generateCode prog css =
  Module
    { moduleHeader = header,
      moduleBody =
        module'
          (Just "Functora.Miso.Theme")
          (Just [thingAll "Theme"])
          ( fmap (qualified' . import')
              $ [ "Prelude",
                  "Data.Data",
                  "GHC.Generics"
                ]
          )
          [ data'
              "Theme"
              mempty
              ( fmap (flip prefixCon mempty . fromString) css
              )
              [ derivingStock
                  $ fmap
                    var
                    [ "Eq",
                      "Ord",
                      "Show",
                      "Read",
                      "Data",
                      "Generic",
                      "Enum",
                      "Bounded"
                    ]
              ]
          ]
    }
  where
    header =
      [ "{- DO NOT EDIT. This file was auto-generated by the "
          <> prog
          <> " program. -}"
          -- languagePragma "DeriveDataTypeable",
          -- optionsGhcPragma "-Wno-missing-export-lists"
      ]

-- languagePragma, optionsGhcPragma :: String -> String
-- languagePragma s = "{-# LANGUAGE " <> s <> "#-}"
-- optionsGhcPragma s = "{-# OPTIONS_GHC " <> s <> "#-}"

writeFileIfChanged :: String -> IO ()
writeFileIfChanged newFile = do
  oldFile <-
    (Just . T.unpack <$> readFile doNotEditFilePath)
      `catchAny` const (pure Nothing)
  when (oldFile /= Just newFile)
    $ writeUTF8File doNotEditFilePath newFile

doNotEditFilePath :: FilePath
doNotEditFilePath =
  "src/Functora/Miso/Theme.hs"
