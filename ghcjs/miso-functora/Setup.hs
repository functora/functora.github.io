{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE PackageImports #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# OPTIONS_GHC -Werror #-}
{-# OPTIONS_GHC -Weverything #-}
{-# OPTIONS_GHC -Wno-all-missed-specialisations #-}
{-# OPTIONS_GHC -Wno-missed-specialisations #-}
{-# OPTIONS_GHC -Wno-missing-exported-signatures #-}
{-# OPTIONS_GHC -Wno-missing-import-lists #-}
{-# OPTIONS_GHC -Wno-missing-local-signatures #-}
{-# OPTIONS_GHC -Wno-safe #-}
{-# OPTIONS_GHC -Wno-unsafe #-}
{-# OPTIONS_GHC -fprint-potential-instances #-}
#if MIN_VERSION_ghc(9,0,0)
{-# OPTIONS_GHC -Wno-missing-kind-signatures #-}
{-# OPTIONS_GHC -Wno-prepositive-qualified-module #-}
{-# OPTIONS_GHC -Wno-missing-safe-haskell-mode #-}
#endif

import qualified Data.Text as T
import Distribution.Simple hiding (Module (..))
import Distribution.Simple.LocalBuildInfo (LocalBuildInfo (..))
import Distribution.Simple.Utils (writeUTF8File)
import Functora.Prelude hiding (empty)
import GHC (runGhc)
import GHC.Paths (libdir)
import GHC.SourceGen
import qualified System.Directory as Directory
import System.Environment (getProgName)
import qualified Text.Casing as Casing

#if MIN_VERSION_ghc(9,0,0)
import "ghc" GHC.Driver.Session (getDynFlags)
import "ghc" GHC.Utils.Outputable
  ( Outputable (..),
    text,
    vcat,
    ($+$),
  )
#else
import "ghc" DynFlags (getDynFlags)
import "ghc" Outputable
  ( Outputable (..),
    text,
    vcat,
    ($+$),
  )
#endif

main :: IO ()
main =
  defaultMainWithHooks
    simpleUserHooks
      { buildHook = \p l h f ->
          codeGenHook l
            >> buildHook simpleUserHooks p l h f
      }

data Module = Module
  { moduleHeader :: [String],
    moduleBody :: HsModule'
  }

instance Outputable Module where
  ppr m =
    vcat (text <$> moduleHeader m)
      $+$ ppr (moduleBody m)

codeGenHook :: LocalBuildInfo -> IO ()
codeGenHook _ = do
  prog <- getProgName
  runGhc (Just libdir) $ do
    dflags <- getDynFlags
    cssRaw <- liftIO $ Directory.listDirectory "dist/themes/"
    let cssKebab =
          sort . fmap (dropEnd 8) $ filter (isSuffixOf ".min.css") cssRaw
    let cssPascal =
          fmap Casing.pascal cssKebab
    if cssKebab == fmap Casing.kebab cssPascal
      then putStrLn $ inspect @Text cssPascal
      else
        error
          $ "Bad kebab <-> pascal isomorphism in "
          <> inspect @Text cssKebab
    liftIO
      . writeFileIfChanged
      . showPpr dflags
      $ generateCode prog cssPascal

generateCode :: String -> [String] -> Module
generateCode prog css =
  Module
    { moduleHeader = header,
      moduleBody =
        module'
          (Just "Functora.Miso.Theme")
          (Just [thingAll "Theme"])
          ( fmap
              import'
              [ "Prelude",
                "Data.Data",
                "Data.Binary",
                "GHC.Generics"
              ]
          )
          [ data'
              "Theme"
              mempty
              ( fmap (flip prefixCon mempty . fromString) css
              )
              [ derivingStock
                  $ fmap
                    var
                    [ "Eq",
                      "Ord",
                      "Show",
                      "Read",
                      "Data",
                      "Generic",
                      "Enum",
                      "Bounded"
                    ]
              ],
            instance' (var "Binary" @@ var "Theme") mempty
          ]
    }
  where
    header =
      [ "{- DO NOT EDIT. This file was auto-generated by the "
          <> prog
          <> " program. -}"
          -- languagePragma "DeriveDataTypeable",
          -- optionsGhcPragma "-Wno-missing-export-lists"
      ]

-- languagePragma, optionsGhcPragma :: String -> String
-- languagePragma s = "{-# LANGUAGE " <> s <> "#-}"
-- optionsGhcPragma s = "{-# OPTIONS_GHC " <> s <> "#-}"

writeFileIfChanged :: String -> IO ()
writeFileIfChanged newFile = do
  oldFile <-
    (Just . T.unpack <$> readFile doNotEditFilePath)
      `catchAny` const (pure Nothing)
  when (oldFile /= Just newFile)
    $ writeUTF8File doNotEditFilePath newFile

doNotEditFilePath :: FilePath
doNotEditFilePath =
  "src/Functora/Miso/Theme.hs"
